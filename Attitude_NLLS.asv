% NLLS of attitude
clc
close all
clear all

time_period = 24*60*60; %1day
global step
step = 100;         %time step for looping calculations
deg2rad = pi/180;
rad2deg = 180/pi;
% Northern: Monday, 20 March 2017 at 10:29 UTC
julian_date17 = juliandate(datetime([2017,3,20,10,29,0]))*86400;

%% Get Estimated and Real Satellite positions over 24h
orbit_params(1)= 7162*1000;              %a - semi major axis meters    
orbit_params(2)=0.0000872;                %e - eccentricity deg
orbit_params(3)=98.7401;                  %inc - inclination degrees
orbit_params(4)=142.1145;                 %Omega - degrees
orbit_params(5)=25.5213;                  %omega - degrees
orbit_params(6)=283.570800000000;         %Mo - Mean Anomaly
orbit_params(7)=2457866.50000000;         %Julian Day (Epoch) Sunday 23/4/17 UT1 00:00:00

% Use code from Assignment 2 to model estimated orbit and real orbit
%[Sat_ECEF_true,Sat_ECI_est, Sat_ECEF_est,Sat_LGCV_est] = Get_Estimated_ECEF(orbit_params);
load('Get_Estimated_ECEF_data')

%% Simulate the Attitude
t = 1:time_period;   %generate times
omega1 = 0.001;     %freq of pitch
omega2 = 0.005;     %freq of yaw

%model pitch and roll as sine waves. yaw is 0
yaw = 0*t;
pitch = pi*sin(omega1*t);
roll =  pi*sin(omega2*t);

Attitude_Real = [yaw;pitch;roll];
% For testing
%plot(t,pitch);
%hold on
%plot(t,roll);

%% Generate constellation of stars

%Greenwich sidereal time at UT[hours] 205.3166 [deg]
th_g0 = 205.3166*deg2rad; %greenwhich sidereal time at epoch
time_epoch = orbit_params(7) * 86400;  %time of epoch in seconds

%constants for generating constellation
r = 10e10;      %some big number 
inc = orbit_params(3);
Omega = orbit_params(4);
omega = orbit_params(5);
num_stars = 100;
% % Generate constellation of stars in ECI
% Star_Constellation1_ECI = Summon_Stars(r,inc,Omega,omega,num_stars);
% Star_Constellation2_ECI = Summon_Stars(r,inc+pi/2,Omega,omega,num_stars);
% Star_Constellation3_ECI = Summon_Stars(r,-(inc+pi/3),Omega,omega,num_stars);
% % Add together the multiple planes of stars
% Star_Constellation_ECI = [Star_Constellation1_ECI;Star_Constellation2_ECI;Star_Constellation3_ECI];
% %FOV is 90 degrees
% FOV = 90*deg2rad;

rvals = 2*rand(1000,1)-1;
elevation = asin(rvals);
azimuth = 2*

figure
plot3(Star_Constellation_ECI(:,1),Star_Constellation_ECI(:,2),Star_Constellation_ECI(:,3),'k.');

%% Get LGCV and Body frame coordinates
%Preallocate for speed
Sat_LLH = zeros(time_period,3);
Mag_ECI = zeros(3,time_period);
Mag_ECEF = zeros(time_period,3);
Mag_LGCV = zeros(time_period,3);
Mag_Body = zeros(time_period,3);

%24 is an arbitrary number of max stars seen
Star_ECI = zeros(24,3,time_period);
Star_ECEF = zeros(24,3,time_period);
Star_LGCV = zeros(24,3,time_period);
Star_Body = zeros(24,3,time_period);

for t = 1:step:time_period
% Convert satellite's estimated ECEF position to est LLH
Sat_LLH(t,:) = ECEF_to_LLH(Sat_ECEF_est(1,t),Sat_ECEF_est(2,t),Sat_ECEF_est(3,t));

% Get unit vector of magnetometer readings
Mag_ECI(:,t) = Get_Mag(t,th_g0, Sat_ECI_est(:,t));

% Convert ECI to ECEF
current_time = time_epoch + t;    %time since last epoch for time = n
t_since_equinox = current_time - julian_date17;
Mag_ECEF(t,:) = ECI_to_ECEF([Mag_ECI(:,t); t_since_equinox]);

% Convert ECEF to LGCV wrt Satellite's position
Mag_LGCV(t,:) =  ECEF_to_LGCV(Sat_LLH(t,1),Sat_LLH(t,2),Sat_LLH(t,3),...
    Mag_ECEF(t,1), Mag_ECEF(t,1), Mag_ECEF(t,1));  

% Convert LGCV to Body using real angles
Mag_Body(t,:) = LGCV_to_Body(Attitude_Real(:,t),Mag_LGCV(t,:));


% Get unit vectors from the star trackers
temp = Get_Star_Tracker(Sat_LLH,t_since_equinox,Star_Constellation_ECI,FOV);
% Size of matrix changes so this code makes sure the matrix can be added
[r,c] = size(temp);
Star_ECI(1:r,:,t) = temp; 

%ECI to ECEF to LGCV to Body with Errors
for k = 1:r
    input = [transpose(Star_ECI(r,:,t)); t_since_equinox];
    %ECI to ECEF
    Star_ECEF(k,:,t) = ECI_to_ECEF(input);
    %ECEF to LGCV
    Star_LGCV(k,:,t) =  ECEF_to_LGCV(Sat_LLH(t,1),Sat_LLH(t,2),Sat_LLH(t,3),...
                Star_ECEF(k,1,t), Star_ECEF(k,2,t), Star_ECEF(k,3,t));  
            
    Star_Body(k,:,t) = LGCV_to_Body(Attitude_Real(:,t),Star_LGCV(k,:,t));
        
end

end

%% Add Errors to Star Tracker and Magnetometer Body Readings
sigma_star = 0.00001;
sigma_mag = 0.001;

sigma_star = 0;
sigma_mag = 0;

% Apply Errors
Mag_Body_Errors = normrnd(Mag_Body,sigma_mag);
Star_Body_Errors = normrnd(Star_Body,sigma_star);


%% Apply NLLS to Determine Attitude for each timestep
% Constants
tol = 0.01;
%Weights matrix same size as readings
weight_star = 1;
weight_mag = 0.01;
%find number of star readings, includes X,Y,Z
[r,c,num_times] = size(Star_LGCV);
Attitude_Est = zeros(num_times,3);

%*************************************** TEMP ****************************
%num_times = 30001;
%*************************************************************************

%loop for the number of times
for t = 1:step:num_times
    %for t = 20601:step:20701

    %init X vector and other variables
    X_vector = [0;0;0];    %yaw, pitch, roll
    delta_x = 10e9;
    itter = 0;

    %clear matricies in case jacobian is a different size
    clear H
    clear y_est
    clear y_meas
    clear weights
    clear delta_y0
    
    % Get number of star readings for this timestep
    num_star_readings(t) = length(find(Star_LGCV(:,1,t)));

    % Perform NLLS
    while norm(delta_x) > tol
        %build jacobian for magnetometer readings
        k = 1;
        %calc estimated body frame coordinates using guess attitude
        y_est(3*k-2:3*k,1) = LGCV_to_Body(X_vector,Mag_LGCV(t,:));
        %build jacobian
        H(3*k-2:3*k,:) = Get_Jacobian_Attitude(X_vector, Mag_LGCV(t,:));
        %organise measurements
        y_meas(3*k-2:3*k,1) = Mag_Body_Errors(t,:);
        %build diagonals of weight matrix
        weights(3*k-2:3*k) = [weight_mag, weight_mag, weight_mag];
        
        %build jacobian for star tracker readings
        for k = 2:num_star_readings(:,t)
            %calc estimated body frame coordinates using guess attitude
            y_est(3*k-2:3*k,1) = LGCV_to_Body(X_vector,Star_LGCV(k,:,t));
            %build jacobian
            H(3*k-2:3*k,:) = Get_Jacobian_Attitude(X_vector, Star_LGCV(k,:,t));
            %organise measurements
            y_meas(3*k-2:3*k,1) = Star_Body_Errors(k,:,t);
            %build diagonals of weight matrix
            weights(3*k-2:3*k) = [weight_star, weight_star, weight_star];
        end
        
        %get delta yo
        delta_y0 = y_meas - y_est;
        %make weights matrix
        W = diag(weights);
        %get delta x
        delta_x = (H'*W*H)\H'*W*delta_y0;
        %add to the X vector
        X_vector = X_vector + delta_x;
        
        %break condition for itterations
        itter = itter + 1;
        if itter > 10
            break;
        end
        
    end     %end tolerance loop for NLLS
    Attitude_Est(t,:) = X_vector;
end

%% Plots
%close all

% Attitude_Est_Pi(:,2) = mod(Attitude_Est(:,2),2*pi);
% rip = Attitude_Est_Pi(:, 2) > pi;
% Attitude_Est_Pi(rip, 2) = Attitude_Est_Pi(rip, 2) - 2*pi;

for t = 1:time_period
    if abs(Attitude_Est(t,2)) > pi || Attitude_Est(t,2) == 0
        Attitude_Est_Pi(t,2) = NaN;
    else
        Attitude_Est_Pi(t,2) = Attitude_Est(t,2);
    end
end
plot(1:time_period,Attitude_Real(2,:),'b')
hold on
plot(1:time_period,Attitude_Est_Pi(:,2),'r.')
title('Filtered')

figure
subplot(2,1,1)
plot(1:time_period,Attitude_Est(1:time_period,2),'r.')
title('Unfilted')
subplot(2,1,2)
plot(abs(num_star_readings),'.');

% figure
% plot(t,pitch,'b')
% hold on
% plot(t,YPR_sun(:,2),'r');
% hold on
% plot(t,YPR_star(:,2),'k');
% title('Pitch vs Time')
% legend('Real Values','Sun Sensor','Star Tracker')